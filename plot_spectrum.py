#!/usr/bin/env python3
"""
Power spectrum visualization script for turbulent velocity initial conditions.

This script reads velocity ICs generated by turb.py and plots their power spectrum
to validate the spectral properties. It can handle both 2D and 3D data.

Usage:
    python3 plot_spectrum.py <ic_directory> [options]

Examples:
    # Basic usage - plot spectrum of velocity ICs
    python3 plot_spectrum.py ./ic_turb_6_3d/
    
    # Compare multiple ICs
    python3 plot_spectrum.py ./ic_turb_6_3d/ ./ic_turb_6_3d_powerlaw/ --labels "Parabolic" "Power Law"
    
    # Save plot to file
    python3 plot_spectrum.py ./ic_turb_6_3d/ --save plot.png
"""

import argparse
import os
import sys
from pathlib import Path
from typing import List, Optional, Tuple

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams

import grafic


def read_velocity_ics(ic_dir: Path) -> Tuple[np.ndarray, np.ndarray, np.ndarray, float]:
    """Read velocity ICs from a directory.
    
    Args:
        ic_dir: Path to directory containing IC files
        
    Returns:
        Tuple of (u, v, w, box_size) where u, v, w are velocity arrays
    """
    # Read velocity components
    u_file = ic_dir / "ic_u"
    v_file = ic_dir / "ic_v"
    w_file = ic_dir / "ic_w"
    
    if not u_file.exists() or not v_file.exists() or not w_file.exists():
        raise FileNotFoundError(f"Velocity IC files not found in {ic_dir}")
    
    # Read data using grafic
    g_u = grafic.Grafic()
    g_v = grafic.Grafic()
    g_w = grafic.Grafic()
    
    g_u.read(str(u_file))
    g_v.read(str(v_file))
    g_w.read(str(w_file))
    
    u = g_u.data
    v = g_v.data
    w = g_w.data
    
    # Get box size from header
    box_size = g_u.header[3] * g_u.header[0]  # dx * n1
    
    return u, v, w, box_size


def compute_power_spectrum(u: np.ndarray, v: np.ndarray, w: np.ndarray, 
                          box_size: float) -> Tuple[np.ndarray, np.ndarray]:
    """Compute the power spectrum of velocity field.
    
    Args:
        u, v, w: Velocity components (can be 2D or 3D)
        box_size: Physical box size in code units
        
    Returns:
        Tuple of (k_bins, power_spectrum) where k_bins are wavenumber bins
    """
    # Handle 2D vs 3D
    if u.ndim == 2:
        # 2D case: assume shape is (n, n, 1) from grafic
        u = u[:, :, 0]
        v = v[:, :, 0]
        w = w[:, :, 0]
        is_2d = True
    else:
        is_2d = False
    
    # Get grid dimensions
    n1, n2, n3 = u.shape
    
    # FFT of velocity components
    U = np.fft.fftn(u)
    V = np.fft.fftn(v)
    W = np.fft.fftn(w)
    
    # Compute wavenumber grid
    kx = np.fft.fftfreq(n1, d=box_size/n1)
    ky = np.fft.fftfreq(n2, d=box_size/n2)
    kz = np.fft.fftfreq(n3, d=box_size/n3)
    
    # Create 3D k-grid
    KX, KY, KZ = np.meshgrid(kx, ky, kz, indexing='ij')
    kmag = np.sqrt(KX**2 + KY**2 + KZ**2)
    
    # Compute velocity magnitude in k-space
    vel_k_mag2 = np.abs(U)**2 + np.abs(V)**2 + np.abs(W)**2
    
    # For 2D, we only care about kx and ky
    if is_2d:
        kmag = np.sqrt(KX**2 + KY**2)
        vel_k_mag2 = np.abs(U)**2 + np.abs(V)**2
    
    # Bin the power spectrum
    k_max = np.max(kmag)
    n_bins = min(50, int(np.sqrt(n1 * n2 * n3) / 2))  # Reasonable number of bins
    
    # Create log-spaced bins
    k_bins = np.logspace(np.log10(k_max/n_bins), np.log10(k_max), n_bins)
    power_spectrum = np.zeros(n_bins)
    
    # Bin the power
    for i in range(n_bins):
        if i == 0:
            mask = kmag <= k_bins[i]
        else:
            mask = (kmag > k_bins[i-1]) & (kmag <= k_bins[i])
        
        if np.any(mask):
            power_spectrum[i] = np.mean(vel_k_mag2[mask])
    
    # Use geometric mean of bin edges for plotting
    k_plot = np.sqrt(k_bins[:-1] * k_bins[1:])
    power_plot = power_spectrum[:-1]
    
    return k_plot, power_plot


def plot_spectrum(ic_dirs: List[Path], labels: Optional[List[str]] = None, 
                  save_path: Optional[str] = None, show_plot: bool = True):
    """Plot power spectra for one or more IC directories.
    
    Args:
        ic_dirs: List of paths to IC directories
        labels: Optional labels for each spectrum
        save_path: Optional path to save the plot
        show_plot: Whether to display the plot
    """
    # Set up the plot
    plt.figure(figsize=(10, 8))
    
    colors = plt.cm.tab10(np.linspace(0, 1, len(ic_dirs)))
    
    for i, ic_dir in enumerate(ic_dirs):
        try:
            print(f"Processing {ic_dir}...")
            u, v, w, box_size = read_velocity_ics(ic_dir)
            
            k_bins, power = compute_power_spectrum(u, v, w, box_size)
            
            # Determine dimensionality
            ndim = "2D" if u.shape[2] == 1 else "3D"
            grid_size = f"{u.shape[0]}x{u.shape[1]}x{u.shape[2]}"
            
            # Plot power spectrum
            label = labels[i] if labels else f"{ic_dir.name} ({ndim}, {grid_size})"
            plt.loglog(k_bins, power, 'o-', color=colors[i], label=label, 
                      markersize=4, linewidth=2)
            
            print(f"  Grid: {grid_size}, Box size: {box_size:.3f}")
            print(f"  Velocity range: u[{u.min():.3f}, {u.max():.3f}], "
                  f"v[{v.min():.3f}, {v.max():.3f}], "
                  f"w[{w.min():.3f}, {w.max():.3f}]")
            
        except Exception as e:
            print(f"Error processing {ic_dir}: {e}")
            continue
    
    # Add theoretical power laws for reference
    k_ref = np.logspace(-1, 1, 100)
    
    # Kolmogorov slope (-5/3)
    plt.loglog(k_ref, k_ref**(-5/3), '--', color='gray', alpha=0.7, 
               label='Kolmogorov (-5/3)', linewidth=1)
    
    # Steep slope (-2)
    plt.loglog(k_ref, k_ref**(-2), ':', color='gray', alpha=0.7, 
               label='Steep (-2)', linewidth=1)
    
    # Flat slope (-1)
    plt.loglog(k_ref, k_ref**(-1), '-.', color='gray', alpha=0.7, 
               label='Flat (-1)', linewidth=1)
    
    plt.xlabel('Wavenumber k')
    plt.ylabel('Power Spectrum P(k)')
    plt.title('Velocity Power Spectrum of Turbulent ICs')
    plt.legend()
    plt.grid(True, alpha=0.3)
    
    # Set reasonable axis limits
    plt.xlim(k_bins.min() * 0.8, k_bins.max() * 1.2)
    
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"Plot saved to {save_path}")
    
    if show_plot:
        plt.show()
    else:
        plt.close()


def main():
    parser = argparse.ArgumentParser(
        description="Plot power spectrum of turbulent velocity ICs",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    parser.add_argument("ic_dirs", nargs="+", type=Path, 
                       help="Directory(ies) containing velocity ICs")
    parser.add_argument("--labels", nargs="+", type=str,
                       help="Labels for each spectrum (must match number of directories)")
    parser.add_argument("--save", type=str, help="Save plot to file")
    parser.add_argument("--no-show", action="store_true", help="Don't display plot")
    
    args = parser.parse_args()
    
    # Validate inputs
    if args.labels and len(args.labels) != len(args.ic_dirs):
        parser.error("Number of labels must match number of IC directories")
    
    # Check that directories exist
    for ic_dir in args.ic_dirs:
        if not ic_dir.exists():
            parser.error(f"IC directory does not exist: {ic_dir}")
        if not ic_dir.is_dir():
            parser.error(f"Not a directory: {ic_dir}")
    
    # Plot the spectra
    plot_spectrum(
        args.ic_dirs,
        labels=args.labels,
        save_path=args.save,
        show_plot=not args.no_show
    )


if __name__ == "__main__":
    main()
