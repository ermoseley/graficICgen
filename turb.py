#!/usr/bin/env python3
"""
Turbulent velocity initial condition generator with configurable spectrum types.

This script generates a divergence/rotation-controlled random velocity field
using spectral filtering between k_min and k_max. It supports 2D (arrays shaped 
(n, n, 1)) and 3D (n, n, n) outputs.

Spectrum types:
  - "parabolic": Band-limited spectrum with w(k) ∝ (k - kmin)(kmax - k)
    - Power is zero outside [kmin, kmax]
    - Good for isolating specific wavenumber bands
  - "power_law": Power law spectrum with w(k) ∝ k^slope within [kmin, kmax]
    - Default slope -5/3 gives Kolmogorov turbulence
    - Maintains power across all scales with smooth cutoffs
    - Allows independent control of slope and wavenumber range

The compressive/solenoidal mix is controlled by --alpha:
  - alpha = 1.0 → purely compressive (curl-free)
  - alpha = 0.0 → purely solenoidal (divergence-free)
  - intermediate values linearly combine the two projections in Fourier space

Velocity fields are generated by filtering and projecting the FFT of initial
Gaussian random fields, which preserves Hermitian symmetry and yields real
outputs upon inverse FFT. Density and pressure are set uniform.

Examples:
  - 3D, level 6, vrms=0.1, k band [2, 16], 50/50 mix, parabolic spectrum:
      python3 turb.py 6 --size 1.0 --ndim 3 --kmin 1 --kmax 3 --alpha 0.5 --vrms 1.0 

  - 2D, level 9, vrms=0.2, mostly solenoidal, power law spectrum (Kolmogorov slope):
      python3 turb.py 9 --size 1.0 --ndim 2 --kmin 2 --kmax 9 --alpha 0.2 --vrms 0.2 \
        --spectrum power_law --slope -5.0/3.0

  - 3D, level 7, vrms=0.15, power law with steeper slope (-2.0), compressive:
      python3 turb.py 7 --size 1.0 --ndim 3 --kmin 3 --kmax 32 --alpha 0.8 --vrms 10.0 \
        --spectrum power_law --slope -2.0

Uniform magnetic field:
  - Add constant components via --bx/--by/--bz to write magnetic field files
    (ic_bxleft/right, ic_byleft/right, ic_bzleft/right).
"""

from __future__ import annotations

import argparse
import os
from pathlib import Path

import numpy as np

import grafic


def write_array(filename: str, array: np.ndarray, box_size_cu: float, *, as_int64: bool = False) -> None:
    """Write a 3D numpy array to a GRAFIC file.

    Args:
        filename: Destination filename (created/overwritten).
        array: 3D array shaped (n1, n2, n3). For 2D output, use n3=1.
        box_size_cu: Physical box size in code units used to set dx in header.
        as_int64: If True, write data as int64; otherwise float32.
    """
    g = grafic.Grafic()
    g.set_data(np.asarray(array))
    g.make_header(box_size_cu)
    if as_int64:
        g.write_int64(filename)
    else:
        g.write_float(filename)


def generate_k_grid(n1: int, n2: int, n3: int) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """Return kx, ky, kz, kmag arrays for an FFT grid with unit box length.

    Uses numpy.fft.fftfreq conventions. kmag=0 at k=(0,0,0).
    """
    kx = np.fft.fftfreq(n1, d=1.0 / n1).reshape(n1, 1, 1)
    ky = np.fft.fftfreq(n2, d=1.0 / n2).reshape(1, n2, 1)
    kz = np.fft.fftfreq(n3, d=1.0 / n3).reshape(1, 1, n3)
    kmag = np.sqrt(kx * kx + ky * ky + kz * kz)
    return kx, ky, kz, kmag


def build_turbulent_velocity(
    n1: int,
    n2: int,
    n3: int,
    kmin: float,
    kmax: float,
    alpha: float,
    vrms: float,
    rng: np.random.Generator,
    spectrum_type: str = "parabolic",
    power_law_slope: float = -5.0/3.0,
) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Create turbulent velocity components (u, v, w) with given spectral controls.

    Steps:
      1) Generate real Gaussian random fields, FFT to get A(k)
      2) Apply spectral filter:
         - "parabolic": w(k) ∝ (k - kmin)(kmax - k) within [kmin,kmax] (band-limited)
         - "power_law": w(k) ∝ k^slope within [kmin,kmax] (power law with cutoff)
      3) Project to compressive (parallel) and solenoidal (perpendicular) parts
      4) Mix with alpha: V = alpha*V_par + (1-alpha)*V_perp
      5) Inverse FFT to real space and normalize to vrms
    """
    # Real-space Gaussian noise
    u0 = rng.standard_normal((n1, n2, n3)).astype(np.float64)
    v0 = rng.standard_normal((n1, n2, n3)).astype(np.float64)
    w0 = rng.standard_normal((n1, n2, n3)).astype(np.float64)

    # FFT to spectral domain
    U = np.fft.fftn(u0)
    V = np.fft.fftn(v0)
    W = np.fft.fftn(w0)

    # k-grid and spectral envelope
    kx, ky, kz, kmag = generate_k_grid(n1, n2, n3)
    with np.errstate(invalid="ignore"):
        band = (kmag >= kmin) & (kmag <= kmax)
        
        if spectrum_type == "parabolic":
            # Parabolic band-pass: w(k) ∝ (k - kmin)(kmax - k) within [kmin,kmax]
            envelope = (kmag - kmin) * (kmax - kmag)
            envelope = np.where(band, envelope, 0.0)
            envelope = np.clip(envelope, 0.0, None)
        elif spectrum_type == "power_law":
            # Power law: w(k) ∝ k^slope within [kmin,kmax]
            # Avoid k=0 and apply smooth cutoff at boundaries
            kmag_safe = np.where(kmag == 0.0, 1.0, kmag)
            envelope = np.where(band, kmag_safe ** power_law_slope, 0.0)
            # Apply smooth cutoff at boundaries to avoid discontinuities
            k_transition = 0.1  # Transition width as fraction of band
            dk = kmax - kmin
            k1 = kmin + k_transition * dk
            k2 = kmax - k_transition * dk
            # Smooth transition at low-k boundary
            low_transition = np.where(
                (kmag >= kmin) & (kmag < k1),
                0.5 * (1.0 + np.cos(np.pi * (kmag - kmin) / (k1 - kmin))),
                1.0
            )
            # Smooth transition at high-k boundary  
            high_transition = np.where(
                (kmag > k2) & (kmag <= kmax),
                0.5 * (1.0 + np.cos(np.pi * (kmag - k2) / (kmax - k2))),
                1.0
            )
            envelope *= low_transition * high_transition
        else:
            raise ValueError(f"Unknown spectrum_type: {spectrum_type}. Use 'parabolic' or 'power_law'")
        
        filt = np.sqrt(envelope, dtype=np.float64)

    # Avoid division by zero at k=0
    kmag_safe = np.where(kmag == 0.0, 1.0, kmag)

    # Projection to compressive (parallel) and solenoidal (perpendicular)
    # dot = k · A
    dot = (kx * U + ky * V + kz * W)
    # Parallel component: (k / |k|^2) * dot
    U_par = kx * dot / (kmag_safe * kmag_safe)
    V_par = ky * dot / (kmag_safe * kmag_safe)
    W_par = kz * dot / (kmag_safe * kmag_safe)
    # Perpendicular component: A - A_par
    U_perp = U - U_par
    V_perp = V - V_par
    W_perp = W - W_par

    # Mix
    a = float(alpha)
    U_mix = a * U_par + (1.0 - a) * U_perp
    V_mix = a * V_par + (1.0 - a) * V_perp
    W_mix = a * W_par + (1.0 - a) * W_perp

    # Apply spectral envelope
    U_mix *= filt
    V_mix *= filt
    W_mix *= filt

    # Enforce zero at k=0
    U_mix[0, 0, 0] = 0.0
    V_mix[0, 0, 0] = 0.0
    W_mix[0, 0, 0] = 0.0

    # Back to real space
    u = np.fft.ifftn(U_mix).real.astype(np.float32)
    v = np.fft.ifftn(V_mix).real.astype(np.float32)
    w = np.fft.ifftn(W_mix).real.astype(np.float32)

    # Normalize to desired vrms
    if n3 == 1:
        speed2 = u * u + v * v
    else:
        speed2 = u * u + v * v + w * w
    rms = float(np.sqrt(np.mean(speed2)))
    if rms > 0:
        s = float(vrms) / rms
        u *= s
        v *= s
        w *= s

    return u, v, w


def main():
    parser = argparse.ArgumentParser(description="Generate band-limited turbulent ICs (GRAFIC format)")
    parser.add_argument("lvl", type=int, help="Refinement level (grid size is 2^lvl)")
    parser.add_argument("--size", type=float, default=1.0, help="Box size in code units (default: 1.0)")
    parser.add_argument("--ndim", type=int, default=3, help="Output dimensionality: 2 or 3 (default: 3)")
    parser.add_argument("--kmin", type=float, default=2.0, help="Minimum wavenumber for band-pass (>=1)")
    parser.add_argument("--kmax", type=float, default=None, help="Maximum wavenumber for band-pass (<= n/2)")
    parser.add_argument("--spectrum", type=str, default="parabolic", choices=["parabolic", "power_law"], 
                       help="Spectrum type: 'parabolic' (band-limited) or 'power_law' (default: parabolic)")
    parser.add_argument("--slope", type=float, default=-5.0/3.0, 
                       help="Power law slope for spectrum='power_law' (default: -5/3, Kolmogorov)")
    parser.add_argument("--alpha", type=float, default=0.5, help="Compressive fraction [0..1] (1=compressive, 0=solenoidal)")
    parser.add_argument("--vrms", type=float, default=0.1, help="Target RMS velocity magnitude")
    parser.add_argument("--rho", type=float, default=1.0, help="Uniform density")
    parser.add_argument("--p0", type=float, default=1.0, help="Uniform pressure")
    parser.add_argument("--bx", type=float, default=0.0, help="Uniform magnetic Bx boundary (left/right)")
    parser.add_argument("--by", type=float, default=0.0, help="Uniform magnetic By boundary (left/right)")
    parser.add_argument("--bz", type=float, default=0.0, help="Uniform magnetic Bz boundary (left/right)")
    parser.add_argument(
        "--outdir",
        type=str,
        default=None,
        help="Output directory for ICs. Default: ./ic_turb/ic_turb_<lvl>d<ndim>",
    )
    parser.add_argument("--seed", type=int, default=42, help="Random seed for reproducibility")
    parser.add_argument("--particles", action="store_true", help="Also write particle ICs (IDs and velocities)")

    args = parser.parse_args()

    lvl = int(args.lvl)
    n = 2 ** lvl
    if args.ndim == 3:
        n1, n2, n3 = n, n, n
    elif args.ndim == 2:
        n1, n2, n3 = n, n, 1
    else:
        raise SystemExit("--ndim must be 2 or 3")

    L = float(args.size)
    kmin = float(args.kmin)
    kmax = float(args.kmax) if args.kmax is not None else n / 2.0
    if not (0.0 <= args.alpha <= 1.0):
        raise SystemExit("--alpha must be in [0,1]")

    rng = np.random.default_rng(args.seed)

    # Generate turbulent velocity components
    u, v, w = build_turbulent_velocity(
        n1, n2, n3, kmin, kmax, args.alpha, args.vrms, rng,
        spectrum_type=args.spectrum, power_law_slope=args.slope
    )

    # Hydrodynamic primitives
    d = np.full((n1, n2, n3), float(args.rho), dtype=np.float32)
    p = np.full((n1, n2, n3), float(args.p0), dtype=np.float32)

    # Determine output dir
    tag = f"ic_turb_{lvl}_{args.ndim}d"
    outdir = Path(args.outdir) if args.outdir is not None else Path("ic_turb") / tag
    os.makedirs(outdir, exist_ok=True)
    os.chdir(outdir)

    # Write hydrodynamic IC files
    write_array("ic_d", d, L)
    write_array("ic_u", u, L)
    write_array("ic_v", v, L)
    write_array("ic_w", w, L)
    write_array("ic_p", p, L)

    # Optional uniform magnetic field boundaries
    if (args.bx != 0.0) or (args.by != 0.0) or (args.bz != 0.0):
        bx = float(args.bx)
        by = float(args.by)
        bz = float(args.bz)
        shape = (n1, n2, n3)
        write_array("ic_bxleft",  np.full(shape, bx, dtype=np.float32), L)
        write_array("ic_bxright", np.full(shape, bx, dtype=np.float32), L)
        write_array("ic_byleft",  np.full(shape, by, dtype=np.float32), L)
        write_array("ic_byright", np.full(shape, by, dtype=np.float32), L)
        write_array("ic_bzleft",  np.full(shape, bz, dtype=np.float32), L)
        write_array("ic_bzright", np.full(shape, bz, dtype=np.float32), L)

    # Optional particle ICs
    if args.particles:
        total = n1 * n2 * n3
        ids = np.arange(1, total + 1, dtype=np.int64)
        rng.shuffle(ids)
        ids = ids.reshape((n1, n2, n3))
        # Set particle velocities equal to gas velocities
        write_array("ic_particle_ids", ids, L, as_int64=True)
        write_array("ic_velcx", u, L)
        write_array("ic_velcy", v, L)
        write_array("ic_velcz", w, L)

    print(f"Turbulent ICs written to: {outdir}")


if __name__ == "__main__":
    main()


